# Rust questions

1. `Pin`: Self-referencing struct  
Write a cache decorator for a struct which has an internal search function which is too complex to be called each time. Say, the struct would contain a cache ref-field to the last found element. How to do it properly?
2. `const fn`: loops  
`for` is forbidden, but `while` is ok.
Since `for` is forbidden in const functions how to bridge the flaw? (via macro capabilities)  
Task: write a max function for a user defined enum
3. Does Rust's safety guarantee that destructors will always run?
4. Lack of specialisation, `Iterator` is not a generic type. What are drawbacks of implementing the `From` trait specified by an `Iterator` type?  
Note: there is a special trait entitled `FromIterator`. Which usually is not used explicitely, but implicitely by `.collect()`  
Note: the root is in the unstability of the `#![feature!(specialization)]`
5. What Rust built-in type is not `FFI` compatible?
6. `Deref`: What would be if the following lines were uncommented?
```
struct MyStruct {
    field: String
}

impl MyStruct {
//    fn vec_func(self: &Vec<Self>) {
//        println!("vec_func");
//    }

    fn box_func(self: &Box<Self>) {
        println!("box_func");
    }
}

fn main() {
    let vms: Vec<MyStruct> = vec![MyStruct { field: "What a mad world!".to_owned() }];
//    vms.func();

    let bms: Box<MyStruct> = Box::new(MyStruct { field: "Hello world!".to_owned()});
    bms.box_func();
}
```
7. `Copy`: What may be printed out by the following code?
```
#[derive(Debug, Copy)]
struct MyStruct {
    field: u32
}

impl Clone for MyStruct {
    fn clone(&self) -> Self {
        Self {
            field: self.field +1
        }
    }
}

fn main() {
    let ms0 = MyStruct{field: 0};
    let ms1 = ms0.clone();
    let ms2 = ms1;
    println!("{:?}", ms0);
    println!("{:?}", ms1);
    println!("{:?}", ms2);
}
```
8. `mut t: &mut T`: What may be printed out by the following code?
```
fn func(mut v: &mut Vec<u32>, mut v2: &mut Vec<u32>) {
    println!("{:?}", v);
    v = v2;
    v[1] = 1000;
    println!("{:?}", v);
}

fn main() {
    let mut v = vec![1,2,3,4];
    let mut v2 = vec![5,6,7,8]; 
    func(&mut v, &mut v2);
    println!("{:?}", v);
    println!("{:?}", v2);
}
```
Extra question: What must be changed to make it compilable? (add lifetimes to func)  
Extra question: What may be changed without any side effects? (`mut` may be removed before v2)  
9. What may be printed out by the following code?
```
fn main() {
    let v = vec![1,5,7,1,7,2,5];
    println!("{:?}", v.iter().enumerate().max_by_key(|(_, &it)| it));
    println!("{:?}", v.iter().enumerate().min_by_key(|(_, &it)| it));
}
```
Note: `Some((9, 7))` and `Some((0, 1))`  
Note: `min()` functions always return ref to the FIRST one  
Note: `max()` functions always return ref to the LAST one  
Extra question: What is the type of `v`? (`Vec<i32>`)  
10. Is there a way to compare refs not contents?
```
fn main() {
    let v = vec![5, 5];

    if v[0] == v[1] {
        println!("YES");
    } else {
        println!("NO");
    }

    if &v[0] == &v[1] {
        println!("YES");
    } else {
        println!("NO");
    }
}
```
Note: `YES` and `YES`, since Rust always compares contents, not addrs, of refs  
11. What will be printed out by the following code?
```
trait IComplex {
  pub const fn get_pair(&self) -> Option<Self>;
}

#[derive(Debug)]
struct Complex {
  x: u32,
  y: u32,
}

impl IComplex for Complex {
  pub const fn get_pair(&self) -> Option<Self> {
    Self {
      x: self.x,
      y: -self.y
    }
  }
}

fn main() {
  let c = Complex{x: 1, y: 4};
  println!("{:?}", c.get_pair());
}
```
Note: `trait`s are not allowed to contain `const fn`  
Note: all `fn`s in `trait`s are implied `pub`, so it is an error  
Note: `trait`s are not allowed to return `Self` if they are not `Sized`
Note: `impl Trait` is not allowed for `trait`s, it is allowed only for freestanding `fn`s without conditional returns of __different__ types. (or within `impl Struct { }`)  
12. Write a `trait` for an `enum` which would contain a function whose return type is an array with all variants of the enum in question?
```
#![feature(generic_const_exprs)]

trait Countable: Sized {
    const LEN: usize;
    fn get_all() -> [Self; <Self as Countable>::LEN];
}

macro_rules! impl_Countable {
    ( $( #[$meta: meta] )* $vis: vis enum $enumname: ident { $( $var: ident ),* $(,)?}) => {
        $( #[$meta] )*
        $vis enum $enumname {
            $( $var ),*
        }

        impl $enumname {
            pub const fn _get_len() -> usize {
                [ $( $enumname::$var ),* ].len()
            }
            pub const fn _get_all() -> [Self; Self::_get_len()] {
                [ $( $enumname::$var ),* ]
            }
        }

        impl Countable for $enumname {
            const LEN: usize = Self::_get_len();
            fn get_all() -> [Self; <Self as Countable>::LEN] {
                Self::_get_all()
            }
        }
    }
}

impl_Countable! {
#[derive(Debug)]
enum MyEnum {
    var1,
    var2,
    var3,
}
}

fn main() {
    println!("{:?}", MyEnum::get_all());
}
```
13. What may be printed out by the following programm?
```
use std::rc::Rc;
use std::sync::RwLock;

fn main() {
    let v = vec![42; 10];
    let r = Rc::new(RwLock::new(0u64));
    let r_clone = r.clone();
    let v2: Vec<u32> = v.iter().map(move |el| {
        *r_clone.write().unwrap() += 1;
        *el
    })
    .take(8)
    .collect();
    println!("{:?}", v2);
    println!("{}", r.read().unwrap());
}
```
Note: the same number as that one which is within the `.take(8)`. Since `map` would be called just THE number of times. NO MORE.  
Note: What about adding `.skip(1)`?
